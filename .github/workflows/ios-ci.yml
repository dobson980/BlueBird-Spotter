name: iOS CI

on:
  push:
    branches:
      - main
      - 'codex/**'
  pull_request:

jobs:
  build-and-unit-test:
    timeout-minutes: 60
    runs-on: macos-26

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select Latest Installed Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          # Avoid release-candidate/toolchain drift that can introduce flaky
          # simulator test startup behavior on hosted runners.
          xcode-version: latest-stable

      - name: Show Xcode Version
        run: xcodebuild -version

      - name: Ensure iOS Simulator Runtime Is Available
        run: |
          set -euo pipefail

          # Hosted images can occasionally miss the iOS 26 runtime even when
          # Xcode is installed. Requesting the iOS platform fills that gap.
          if ! xcrun simctl list runtimes available | grep -Eq "iOS 26(\\.| )"; then
            echo "No iOS 26 runtime detected. Downloading iOS platform runtime..."
            xcodebuild -downloadPlatform iOS
          fi

          echo "Available simulator runtimes:"
          xcrun simctl list runtimes available
          echo "Available simulator devices:"
          xcrun simctl list devices available

      - name: Create and Boot Dedicated iOS 26 Simulator
        timeout-minutes: 15
        run: |
          set -euo pipefail

          run_with_timeout() {
            local timeout_seconds="$1"
            shift

            "$@" &
            local command_pid=$!
            local started_at
            started_at="$(date +%s)"

            while kill -0 "${command_pid}" 2>/dev/null; do
              local now elapsed
              now="$(date +%s)"
              elapsed="$((now - started_at))"
              if [ "${elapsed}" -ge "${timeout_seconds}" ]; then
                echo "Timed out after ${timeout_seconds}s while running: $*"
                kill -TERM "${command_pid}" 2>/dev/null || true
                sleep 2
                kill -KILL "${command_pid}" 2>/dev/null || true
                wait "${command_pid}" 2>/dev/null || true
                return 124
              fi
              sleep 2
            done

            wait "${command_pid}"
          }

          wait_for_bootstatus_with_timeout() {
            local simulator_id="$1"
            local timeout_seconds="$2"

            xcrun simctl bootstatus "${simulator_id}" -b &
            local bootstatus_pid=$!
            local started_at
            started_at="$(date +%s)"

            while kill -0 "${bootstatus_pid}" 2>/dev/null; do
              local now elapsed
              now="$(date +%s)"
              elapsed="$((now - started_at))"
              if [ "${elapsed}" -ge "${timeout_seconds}" ]; then
                echo "Timed out waiting for simulator ${simulator_id} to finish booting after ${timeout_seconds}s."
                kill -TERM "${bootstatus_pid}" 2>/dev/null || true
                sleep 2
                kill -KILL "${bootstatus_pid}" 2>/dev/null || true
                wait "${bootstatus_pid}" 2>/dev/null || true
                return 124
              fi
              sleep 2
            done

            wait "${bootstatus_pid}"
          }

          runtime_id="$(
            xcrun simctl list runtimes available | \
            awk -F ' - ' '
              /iOS 26/ && /SimRuntime\.iOS/ {
                id = $NF;
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", id);
                print id;
                found = 1;
                exit;
              }
              END {
                if (!found) {
                  exit 1;
                }
              }
            '
          )"

          device_type_id="$(
            xcrun simctl list devicetypes | \
            awk -F '[()]' '
              /iPhone 17/ { print $2; foundPreferred = 1; exit }
              /iPhone/ && !fallback { fallback = $2 }
              END {
                if (!foundPreferred && fallback != "") {
                  print fallback
                }
              }
            '
          )"

          if [ -z "${runtime_id}" ] || [ -z "${device_type_id}" ]; then
            echo "Unable to resolve iOS 26 runtime or iPhone device type."
            xcrun simctl list runtimes available
            xcrun simctl list devicetypes
            exit 1
          fi

          max_boot_attempts=3
          boot_command_timeout_seconds=120
          boot_timeout_seconds=240
          simulator_id=""
          simulator_name=""

          for attempt in $(seq 1 "${max_boot_attempts}"); do
            simulator_name="BlueBird Spotter CI ${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${attempt}"
            simulator_id="$(xcrun simctl create "${simulator_name}" "${device_type_id}" "${runtime_id}")"
            echo "Boot attempt ${attempt}/${max_boot_attempts} with simulator ${simulator_id}."

            if ! run_with_timeout "${boot_command_timeout_seconds}" xcrun simctl boot "${simulator_id}"; then
              echo "simctl boot failed or timed out on attempt ${attempt}."
            fi

            if wait_for_bootstatus_with_timeout "${simulator_id}" "${boot_timeout_seconds}"; then
              echo "Simulator booted successfully on attempt ${attempt}."
              break
            fi

            echo "Simulator failed to boot on attempt ${attempt}. Collecting diagnostics and retrying..."
            xcrun simctl list devices available || true
            xcrun simctl list devices unavailable || true
            xcrun simctl shutdown "${simulator_id}" || true
            xcrun simctl delete "${simulator_id}" || true

            # CoreSimulator can become unhealthy on hosted runners; restart services before retry.
            killall -9 Simulator 2>/dev/null || true
            killall -9 com.apple.CoreSimulator.CoreSimulatorService 2>/dev/null || true
            xcrun simctl shutdown all || true

            simulator_id=""
            simulator_name=""
          done

          if [ -z "${simulator_id}" ]; then
            echo "Unable to boot a dedicated simulator after ${max_boot_attempts} attempts."
            exit 1
          fi

          echo "SIMULATOR_ID=${simulator_id}" >> "$GITHUB_ENV"
          echo "SIMULATOR_NAME=${simulator_name}" >> "$GITHUB_ENV"
          echo "Using simulator id: ${simulator_id}"

      - name: Run Unit Tests
        timeout-minutes: 25
        run: |
          set -euo pipefail

          # Emit a periodic heartbeat so long-running compile/test phases remain
          # visible in GitHub logs instead of appearing frozen.
          (
            while true; do
              echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] Unit test job still running..."
              sleep 60
            done
          ) &
          heartbeat_pid=$!
          trap 'kill "${heartbeat_pid}" 2>/dev/null || true' EXIT

          xcodebuild \
            -scheme "BlueBird Spotter UnitTests" \
            -destination "platform=iOS Simulator,id=$SIMULATOR_ID,arch=arm64" \
            -destination-timeout 120 \
            -parallel-testing-enabled NO \
            -maximum-concurrent-test-simulator-destinations 1 \
            -maximum-concurrent-test-device-destinations 1 \
            -only-testing:"BlueBird SpotterTests" \
            -skip-testing:"BlueBird SpotterUITests" \
            -derivedDataPath "$RUNNER_TEMP/BlueBirdSpotter-DerivedData" \
            -resultBundlePath "$RUNNER_TEMP/BlueBirdSpotter-UnitTests.xcresult" \
            CODE_SIGNING_ALLOWED=NO \
            COMPILER_INDEX_STORE_ENABLE=NO \
            ENABLE_PREVIEWS=NO \
            test

      - name: Delete Dedicated Simulator
        if: always()
        run: |
          set +e
          if [ -n "${SIMULATOR_ID:-}" ]; then
            xcrun simctl shutdown "${SIMULATOR_ID}" || true
            xcrun simctl delete "${SIMULATOR_ID}" || true
          fi

      - name: Upload Unit Test Result Bundle
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: BlueBirdSpotter-UnitTests-xcresult
          path: ${{ runner.temp }}/BlueBirdSpotter-UnitTests.xcresult
          if-no-files-found: ignore
